#!/usr/bin/env stargate-shell
# Test closures on command objects using unit testing framework
# This demonstrates how functional programming works with structured command output

use ut;

# Test 1: Map - Extract all file names
[test]
fn test_map_extract_names() {
    let names = (list-directory "/tmp").entries.map(entry: entry.name);
    ut.assert_true(names.size() > 0, "Should extract names from entries");
}

# Test 2: Filter - Get only specific file types
[test]
fn test_filter_file_types() {
    let all_entries = (list-directory "/tmp").entries;
    let files = all_entries.filter(entry: entry.type == "file");
    let dirs = all_entries.filter(entry: entry.type == "directory");
    
    ut.assert_true(files.size() >= 0, "Should filter files");
    ut.assert_true(dirs.size() >= 0, "Should filter directories");
}

# Test 3: Reduce - Calculate total size
[test]
fn test_reduce_total_size() {
    let total_size = (list-directory "/tmp").entries.reduce(0, acc, entry: acc + entry.size);
    ut.assert_true(total_size >= 0, "Total size should be non-negative");
}

# Test 4: Chain - Complex query with multiple operations
[test]
fn test_chain_operations() {
    let result = (list-directory "/tmp").entries
        .filter(entry: entry.type == "file")
        .map(entry: entry.size)
        .reduce(0, acc, size: acc + size);
    
    ut.assert_true(result >= 0, "Chained operations should work");
}

# Test 5: Extract specific fields
[test]
fn test_extract_fields() {
    let types = (list-directory "/tmp").entries.map(entry: entry.type);
    ut.assert_true(types.size() > 0, "Should extract type field");
    
    # Verify types are valid
    for type in types {
        let valid = (type == "file") || (type == "directory") || (type == "symlink");
        ut.assert_true(valid, "Type should be file, directory, or symlink");
    }
}

# Test 6: Count specific types
[test]
fn test_count_by_type() {
    let entries = (list-directory "/tmp").entries;
    let file_count = entries.filter(e: e.type == "file").size();
    let dir_count = entries.filter(e: e.type == "directory").size();
    
    ut.assert_true(file_count >= 0, "File count should be non-negative");
    ut.assert_true(dir_count >= 0, "Directory count should be non-negative");
}

# Test 7: Property access on command object
[test]
fn test_command_object_properties() {
    let total_count = (list-directory "/tmp").total_count;
    ut.assert_true(total_count > 0, "Should have total_count property");
}

# Test 8: Inline everything for maximum expressivity
[test]
fn test_maximum_expressivity() {
    # Ultra-concise one-liner: count files
    let file_count = (list-directory "/tmp").entries.filter(e: e.type == "file").size();
    ut.assert_true(file_count >= 0, "One-liner should work");
    
    # Complex inline query
    let large_files = (list-directory "/tmp").entries
        .filter(e: e.type == "file")
        .filter(e: e.size > 0)
        .size();
    ut.assert_true(large_files >= 0, "Complex inline query should work");
}

print ut.stats;
exit(ut.healthy);
