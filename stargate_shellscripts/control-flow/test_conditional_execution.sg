#!/usr/bin/env stargate-shell
# Test conditional execution with && operator

use ut;

[test]
fn test_and_operator_success() {
    # Both commands should execute when first succeeds
    let result = execute-process("/bin/sh", "-c", "echo 'first' && echo 'second'");
    ut.assert_true(result.contains("first"), "First command should execute");
    ut.assert_true(result.contains("second"), "Second command should execute after first succeeds");
}

[test]
fn test_and_operator_failure() {
    # Second command should NOT execute when first fails
    let result = execute-process("/bin/sh", "-c", "(exit 1) && echo 'should not see this' || true");
    ut.assert_equals(result, "", "Second command should not execute after first fails");
}

[test]
fn test_and_operator_chain() {
    # Test chaining multiple commands
    let result = execute-process("/bin/sh", "-c", "echo 'one' && echo 'two' && echo 'three'");
    ut.assert_true(result.contains("one"), "First command should execute");
    ut.assert_true(result.contains("two"), "Second command should execute");
    ut.assert_true(result.contains("three"), "Third command should execute");
}

[test]
fn test_and_operator_stops_on_failure() {
    # Chain should stop at first failure
    let result = execute-process("/bin/sh", "-c", "echo 'one' && (exit 1) && echo 'three' || true");
    ut.assert_true(result.contains("one"), "First command should execute");
    let has_three = result.contains("three");
    ut.assert_true(!has_three, "Third command should not execute after second fails");
}

print ut.stats;
exit(ut.healthy);
