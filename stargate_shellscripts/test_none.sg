#!/usr/bin/env stargate-shell

use ut;

[test]
fn test_none_assignment() {
    let x = none;
    ut.assert_equals(x, none, "none should equal none");
}

[test]
fn test_none_in_list() {
    let list = [1, 2, none, 4];
    ut.assert_equals(list[2], none, "list should contain none");
}

[test]
fn test_none_in_dict() {
    let dict = {"a": 1, "b": none, "c": 3};
    ut.assert_equals(dict["b"], none, "dict value should be none");
}

[test]
fn test_none_not_equal_to_values() {
    ut.assert_not_equals(none, 0, "none should not equal 0");
    ut.assert_not_equals(none, "", "none should not equal empty string");
    ut.assert_not_equals(none, false, "none should not equal false");
}

[test]
fn test_is_none_on_none() {
    let x = none;
    ut.assert_true(x.is_none(), "none.is_none() should be true");
}

[test]
fn test_is_none_on_value() {
    let x = 42;
    ut.assert_true(x.is_some(), "value should be some");
    ut.assert_equals(x.is_none(), false, "value.is_none() should be false");
}

[test]
fn test_is_some_on_none() {
    let x = none;
    ut.assert_true(!x.is_some(), "none.is_some() should be false");
}

[test]
fn test_is_some_on_value() {
    let x = "hello";
    ut.assert_true(x.is_some(), "value.is_some() should be true");
}

[test]
fn test_unwrap_on_value() {
    let x = 100;
    let result = x.unwrap();
    ut.assert_equals(result, 100, "unwrap() should return the value");
}

[test]
fn test_unwrap_or_with_none() {
    let x = none;
    let result = x.unwrap_or(42);
    ut.assert_equals(result, 42, "none.unwrap_or(42) should return 42");
}

[test]
fn test_unwrap_or_with_value() {
    let x = 100;
    let result = x.unwrap_or(42);
    ut.assert_equals(result, 100, "value.unwrap_or(42) should return value");
}

[test]
fn test_expect_with_value() {
    let x = "data";
    let result = x.expect("Should have data");
    ut.assert_equals(result, "data", "expect() should return the value");
}

[test]
fn test_none_is_falsy() {
    let x = none;
    if x {
        ut.assert_true(false, "none should be falsy");
    } else {
        ut.assert_true(true, "none is falsy");
    }
}

[test]
fn test_value_is_truthy() {
    let x = 42;
    if x {
        ut.assert_true(true, "value should be truthy");
    } else {
        ut.assert_true(false, "value is truthy");
    }
}

[test]
fn test_none_with_negation() {
    let x = none;
    if !x {
        ut.assert_true(true, "!none should be true");
    }
}

[test]
fn test_none_bool_conversion() {
    let x = none;
    ut.assert_true(!x, "none should be falsy");
}

[test]
fn test_none_plus_empty_string() {
    let x = none + "";
    ut.assert_equals(x, "", "none + empty string should be empty string");
}

[test]
fn test_empty_string_plus_none() {
    let x = "" + none;
    ut.assert_equals(x, "", "empty string + none should be empty string");
}

[test]
fn test_none_plus_string() {
    let x = none + "hello";
    ut.assert_equals(x, "hello", "none + 'hello' should be 'hello'");
}

[test]
fn test_string_plus_none() {
    let x = "hello" + none;
    ut.assert_equals(x, "hello", "'hello' + none should be 'hello'");
}

[test]
fn test_none_plus_none() {
    let x = none + none;
    ut.assert_equals(x, "", "none + none should be empty string");
}

[test]
fn test_none_concat_transparent() {
    let prefix = none;
    let name = "World";
    
    let greeting = "Hello " + prefix + name;
    ut.assert_equals(greeting, "Hello World", "none is transparent in concatenation");
}

[test]
fn test_mixed_concatenation() {
    let a = "Start";
    let b = none;
    let c = " ";
    let d = none;
    let e = "End";
    
    let result = a + b + c + d + e;
    ut.assert_equals(result, "Start End", "Multiple nones in concatenation");
}

[test]
fn test_function_return_none() {
    fn get_nothing() {
        return none;
    }
    
    let result = get_nothing();
    ut.assert_equals(result, none, "function should return none");
}

[test]
fn test_function_implicit_none() {
    fn no_return() {
        let x = 5;
    }
    
    let result = no_return();
    ut.assert_equals(result, none, "function without return should return none");
}

[test]
fn test_function_returning_none() {
    fn find_user(id) {
        if id == 1 {
            return "Alice";
        }
        return none;
    }
    
    let user1 = find_user(1);
    ut.assert_true(user1.is_some(), "Should find user 1");
    ut.assert_equals(user1, "Alice", "User 1 should be Alice");
    
    let user2 = find_user(2);
    ut.assert_true(user2.is_none(), "Should not find user 2");
}

[test]
fn test_unwrap_or_for_defaults() {
    fn safe_divide(a, b) {
        if b == 0 {
            return none;
        }
        return a / b;
    }
    
    let result1 = safe_divide(10, 2).unwrap_or(0);
    ut.assert_equals(result1, 5, "Normal division");
    
    let result2 = safe_divide(10, 0).unwrap_or(0);
    ut.assert_equals(result2, 0, "Division by zero returns none, unwrap to default");
}

[test]
fn test_config_with_defaults() {
    fn get_config(key) {
        let config = {"host": "localhost", "port": 8080, "debug": true};
        return config.get(key);
    }
    
    let host = get_config("host").unwrap_or("0.0.0.0");
    ut.assert_equals(host, "localhost", "Use configured value");
    
    let timeout = get_config("timeout").unwrap_or(30);
    ut.assert_equals(timeout, 30, "Use default for missing config");
}

[test]
fn test_early_return_on_none() {
    fn validate_and_process(data) {
        if !data {
            return "error";
        }
        return "ok: " + data;
    }
    
    ut.assert_equals(validate_and_process(none), "error", "Early return on none");
    ut.assert_equals(validate_and_process("input"), "ok: input", "Process valid input");
}

[test]
fn test_dict_get_returns_none() {
    let config = {"host": "localhost", "port": 8080};
    
    let host = config.get("host");
    ut.assert_true(host.is_some(), "host should be present");
    
    let db = config.get("database");
    ut.assert_true(db.is_none(), "database should be none");
    
    let db_name = config.get("database").unwrap_or("default_db");
    ut.assert_equals(db_name, "default_db", "Should use default");
}

[test]
fn test_dict_get_missing_key() {
    let dict = {"key": "value"};
    let missing = dict.get("nonexistent");
    ut.assert_equals(missing, none, "get() should return none for missing key");
}

[test]
fn test_direct_none_check() {
    fn find_user(id) {
        if id == 1 {
            return "Alice";
        }
        return none;
    }
    
    let user = find_user(2);
    if !user {
        ut.assert_true(true, "Should detect none with !user");
    }
}

[test]
fn test_none_in_string_building() {
    fn get_title() {
        return none;
    }
    
    let name = get_title() + "Smith";
    ut.assert_equals(name, "Smith", "none disappears in string concat");
    
    let formal_name = get_title().unwrap_or("Mr. ") + "Smith";
    ut.assert_equals(formal_name, "Mr. Smith", "Explicit default");
}

[test]
fn test_conditional_string_building() {
    fn get_prefix(use_prefix) {
        if use_prefix {
            return "Mr. ";
        }
        return none;
    }
    
    let name1 = get_prefix(true) + "Smith";
    ut.assert_equals(name1, "Mr. Smith", "Should include prefix");
    
    let name2 = get_prefix(false) + "Jones";
    ut.assert_equals(name2, "Jones", "Should skip none prefix");
}

[test]
fn test_optional_list_operations() {
    fn find_in_list(items, target) {
        for item in items {
            if item == target {
                return item;
            }
        }
        return none;
    }
    
    let numbers = [1, 2, 3, 4, 5];
    
    let found = find_in_list(numbers, 3);
    if found {
        ut.assert_equals(found, 3, "Found item");
    }
    
    let not_found = find_in_list(numbers, 99);
    if !not_found {
        ut.assert_true(true, "Item not found returns none");
    }
}

[test]
fn test_none_with_strings() {
    let x = none;
    let y = "hello";
    
    let str_x = x.unwrap_or("default");
    let str_y = y.unwrap_or("default");
    
    ut.assert_equals(str_x, "default", "none should use default");
    ut.assert_equals(str_y, "hello", "value should remain unchanged");
}

[test]
fn test_none_with_booleans() {
    let x = none;
    let y = true;
    
    ut.assert_true(!x.is_some(), "none is not some");
    ut.assert_true(y.is_some(), "true is some");
    
    let bool_x = x.unwrap_or(false);
    ut.assert_equals(bool_x, false, "none should unwrap to false");
}

print ut.stats;
exit(ut.healthy);
