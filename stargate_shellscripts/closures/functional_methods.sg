#!/usr/bin/env stargate-shell
# Demonstrate functional programming methods with closures

use ut;

# Test .map() - transform each element
[test]
fn test_map_double() {
    let numbers = [1, 2, 3, 4, 5];
    let doubled = numbers.map(|x| x * 2);
    
    ut.assert_equals(doubled.size(), 5, "Mapped list should have 5 elements");
    ut.assert_equals(doubled[0], 2, "First element should be 2");
    ut.assert_equals(doubled[1], 4, "Second element should be 4");
    ut.assert_equals(doubled[4], 10, "Last element should be 10");
}

[test]
fn test_map_square() {
    let numbers = [1, 2, 3, 4];
    let squared = numbers.map(|n| n * n);
    
    ut.assert_equals(squared[0], 1, "1^2 = 1");
    ut.assert_equals(squared[1], 4, "2^2 = 4");
    ut.assert_equals(squared[2], 9, "3^2 = 9");
    ut.assert_equals(squared[3], 16, "4^2 = 16");
}

[test]
fn test_map_to_string() {
    let numbers = [1, 2, 3];
    let strings = numbers.map(|n| n + 10);
    
    ut.assert_equals(strings[0], 11, "1 + 10 = 11");
    ut.assert_equals(strings[1], 12, "2 + 10 = 12");
    ut.assert_equals(strings[2], 13, "3 + 10 = 13");
}

# Test .filter() - keep only matching elements
[test]
fn test_filter_evens() {
    let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    let evens = numbers.filter(|x| x % 2 == 0);
    
    ut.assert_equals(evens.size(), 5, "Should have 5 even numbers");
    ut.assert_equals(evens[0], 2, "First even is 2");
    ut.assert_equals(evens[1], 4, "Second even is 4");
    ut.assert_equals(evens[4], 10, "Last even is 10");
}

[test]
fn test_filter_greater_than() {
    let numbers = [5, 10, 15, 20, 25];
    let filtered = numbers.filter(|n| n > 12);
    
    ut.assert_equals(filtered.size(), 3, "Should have 3 numbers > 12");
    ut.assert_equals(filtered[0], 15, "First is 15");
    ut.assert_equals(filtered[1], 20, "Second is 20");
    ut.assert_equals(filtered[2], 25, "Third is 25");
}

[test]
fn test_filter_empty_result() {
    let numbers = [1, 2, 3];
    let filtered = numbers.filter(|n| n > 100);
    
    ut.assert_equals(filtered.size(), 0, "No numbers > 100");
}

# Test .reduce() - accumulate a result
[test]
fn test_reduce_sum() {
    let numbers = [1, 2, 3, 4, 5];
    let sum = numbers.reduce(0, |acc, x| acc + x);
    
    ut.assert_equals(sum, 15, "Sum of 1+2+3+4+5 = 15");
}

[test]
fn test_reduce_product() {
    let numbers = [2, 3, 4];
    let product = numbers.reduce(1, |acc, x| acc * x);
    
    ut.assert_equals(product, 24, "Product of 2*3*4 = 24");
}

[test]
fn test_reduce_max() {
    let numbers = [3, 7, 2, 9, 1];
    # Find max using comparison - if x > acc, result is x, else acc
    let max = numbers.reduce(0, |acc, x| acc + x);
    # For now, just test reduction works - proper max would need if-expression support
    
    ut.assert_equals(max, 22, "Sum is 22 (3+7+2+9+1)");
}

[test]
fn test_reduce_count() {
    let numbers = [1, 2, 3, 4, 5];
    let count = numbers.reduce(0, |acc, x| acc + 1);
    
    ut.assert_equals(count, 5, "Count should be 5");
}

# Test chaining functional methods
[test]
fn test_chain_map_filter() {
    let numbers = [1, 2, 3, 4, 5, 6];
    # Double each number, then filter for values > 5
    let result = numbers.map(|x| x * 2).filter(|x| x > 5);
    
    ut.assert_equals(result.size(), 4, "Should have 4 values");
    ut.assert_equals(result[0], 6, "First is 6 (3*2)");
    ut.assert_equals(result[1], 8, "Second is 8 (4*2)");
    ut.assert_equals(result[2], 10, "Third is 10 (5*2)");
    ut.assert_equals(result[3], 12, "Fourth is 12 (6*2)");
}

[test]
fn test_chain_filter_map() {
    let numbers = [1, 2, 3, 4, 5];
    # Filter evens, then square them
    let result = numbers.filter(|x| x % 2 == 0).map(|x| x * x);
    
    ut.assert_equals(result.size(), 2, "Should have 2 values");
    ut.assert_equals(result[0], 4, "2^2 = 4");
    ut.assert_equals(result[1], 16, "4^2 = 16");
}

[test]
fn test_chain_map_filter_reduce() {
    let numbers = [1, 2, 3, 4, 5];
    # Square, filter > 10, sum
    let result = numbers
        .map(|x| x * x)
        .filter(|x| x > 10)
        .reduce(0, |acc, x| acc + x);
    
    # Squares: [1, 4, 9, 16, 25]
    # Filtered (> 10): [16, 25]
    # Sum: 41
    ut.assert_equals(result, 41, "Sum of squares > 10 = 41");
}

# Test with different data types
[test]
fn test_map_with_booleans() {
    let numbers = [0, 1, 2, 0, 3];
    let bools = numbers.map(|x| x != 0);
    
    ut.assert_equals(bools[0], false, "0 != 0 is false");
    ut.assert_equals(bools[1], true, "1 != 0 is true");
    ut.assert_equals(bools[2], true, "2 != 0 is true");
    ut.assert_equals(bools[3], false, "0 != 0 is false");
}

[test]
fn test_filter_with_comparison() {
    let values = [5, -2, 10, -8, 3, -1];
    let positives = values.filter(|x| x > 0);
    
    ut.assert_equals(positives.size(), 3, "Should have 3 positive numbers");
    ut.assert_equals(positives[0], 5, "First positive is 5");
    ut.assert_equals(positives[1], 10, "Second positive is 10");
    ut.assert_equals(positives[2], 3, "Third positive is 3");
}

# Test edge cases
[test]
fn test_map_empty_list() {
    let empty = [];
    let result = empty.map(|x| x * 2);
    
    ut.assert_equals(result.size(), 0, "Mapping empty list gives empty list");
}

[test]
fn test_filter_all_match() {
    let numbers = [2, 4, 6, 8];
    let result = numbers.filter(|x| x % 2 == 0);
    
    ut.assert_equals(result.size(), 4, "All elements match");
}

[test]
fn test_reduce_single_element() {
    let single = [42];
    let result = single.reduce(0, |acc, x| acc + x);
    
    ut.assert_equals(result, 42, "Reduce with single element");
}

print ut.stats;
exit(ut.healthy);
