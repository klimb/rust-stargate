use ut;
[test]
fn test_apply_extract_property() {
    let count = (list-directory "/tmp").apply(obj: obj.total_count);
    ut.assert_true(count > 0, "Should extract total_count property");
}
[test]
fn test_apply_transform_entries() {
    let file_names = (list-directory "/tmp").apply(obj: obj.entries.map(e: e.name));
    ut.assert_true(file_names.size() > 0, "Should get list of file names");
}
[test]
fn test_apply_filter_entries() {
    let rust_files = (list-directory "/tmp").apply(obj: 
        obj.entries.filter(e: e.name.ends_with(".rs"))
    );
    ut.assert_true(rust_files.size() >= 0, "Should filter .rs files");
}
[test]
fn test_apply_complex_pipeline() {
    let total_size = (list-directory "/tmp").apply(obj:
        obj.entries
            .filter(e: e.type == "file")
            .map(e: e.size)
            .reduce(0, a, b: a + b)
    );
    ut.assert_true(total_size >= 0, "Should calculate total file size");
}
[test]
fn test_chain_apply_on_object() {
    let result = (list-directory "/tmp")
        .apply(obj: obj.entries)
        .apply(list: list.size());
    ut.assert_true(result > 0, "Should chain apply calls on object");
}
[test]
fn test_apply_nested_array() {
    let types = (list-directory "/tmp").apply(obj: obj.entries.map(e: e.type));
    ut.assert_true(types.size() > 0, "Should extract type array");
}
[test]
fn test_apply_multi_transform() {
    let large_files = (list-directory "/tmp").apply(obj:
        obj.entries
            .filter(e: e.type == "file")
            .filter(e: e.size > 1000)
    );
    ut.assert_true(large_files.size() >= 0, "Should filter large files");
}
[test]
fn test_apply_count_directories() {
    let dir_count = (list-directory "/tmp").apply(obj:
        obj.entries
            .filter(e: e.type == "directory")
            .size()
    );
    ut.assert_true(dir_count >= 0, "Should count directories");
}
print ut.stats;
exit(ut.healthy);
