use ut;

fn is_even(n) {
    let remainder = n % 2;
    if remainder == 0 {
        return 1;
    }

    return 0;
}

fn is_prime(n) {
    if n <= 1 {
        return 0;
    }

    if n == 2 {
        return 1;
    }

    if is_even(n) == 1 {
        return 0;
    }

    let divisor = 3;
    let limit = n / 2;
    for i in range(3, limit + 1) {
        let remainder = n % i;
        if remainder == 0 {
            return 0;
        }
    }

    return 1;
}

fn factorial(n) {
    if n <= 1 {
        return 1;
    }

    let result = 1;
    for i in range(2, n + 1) {
        let result = result * i;
    }

    return result;
}

fn fibonacci_recursive(n) {
    if n <= 1 {
        return n;
    }

    let a = fibonacci_recursive(n - 1);
    let b = fibonacci_recursive(n - 2);
    return a + b;
}

fn max(a, b) {
    if a > b {
        return a;
    }

    return b;
}

fn min(a, b) {
    if a < b {
        return a;
    }

    return b;
}

fn abs(n) {
    if n < 0 {
        return 0 - n;
    }

    return n;
}

fn in_range(n, minimum, maximum) {
    if n >= minimum && n <= maximum {
        return 1;
    }

    return 0;
}

fn classify_number(n) {
    let is_neg = n < 0;
    let is_zero = n == 0;
    let is_pos = n > 0;
    let even = is_even(n);
    let prime = is_prime(abs(n));
    if is_zero {
        return "zero";
    }

    if is_neg {
        if even == 1 {
            return "negative_even";
        }

        return "negative_odd";
    }

    if prime == 1 {
        return "prime";
    }

    if even == 1 {
        return "positive_even";
    }

    return "positive_odd";
}

class MathOperations {

    fn init() {
    }

    fn power(base, exp) {
        if exp == 0 {
            return 1;
        }

        let result = base;
        for i in range(1, exp) {
            let result = result * base;
        }

        return result;
    }

    fn sum_range(start, end) {
        let total = 0;
        for i in range(start, end + 1) {
            let total = total + i;
        }

        return total;
    }
}

class NumberAnalyzer extends MathOperations {

    fn init() {
    }

    fn analyze(n) {
        let classification = classify_number(n);
        return classification;
    }
}

[test]
fn test_even_odd() {
    ut.assert_equals(is_even(42), 1, "42 should be even");
    ut.assert_equals(is_even(17), 0, "17 should be odd");
}

[test]
fn test_prime() {
    ut.assert_equals(is_prime(17), 1, "17 should be prime");
    ut.assert_equals(is_prime(18), 0, "18 should not be prime");
}

[test]
fn test_factorial() {
    ut.assert_equals(factorial(5), 120, "5! should be 120");
}

[test]
fn test_fibonacci() {
    ut.assert_equals(fibonacci_recursive(6), 8, "fib(6) should be 8");
}

[test]
fn test_min_max_abs() {
    ut.assert_equals(max(45, 23), 45, "max(45, 23) should be 45");
    ut.assert_equals(min(45, 23), 23, "min(45, 23) should be 23");
    ut.assert_equals(abs(0 - 15), 15, "abs(-15) should be 15");
}

[test]
fn test_classification() {
    ut.assert_equals(classify_number(0), "zero", "0 should be zero");
    ut.assert_equals(classify_number(17), "prime", "17 should be prime");
    ut.assert_equals(classify_number(8), "positive_even", "8 should be positive_even");
    ut.assert_equals(classify_number(9), "positive_odd", "9 should be positive_odd");
}

[test]
fn test_class_methods() {
    let math = new MathOperations();
    ut.assert_equals(math.power(2, 10), 1024, "2^10 should be 1024");
    ut.assert_equals(math.sum_range(1, 10), 55, "sum(1..10) should be 55");
}

[test]
fn test_inheritance() {
    let analyzer = new NumberAnalyzer();
    ut.assert_equals(analyzer.analyze(13), "prime", "13 should be prime");
}

[test]
fn test_nested_conditions() {
    let test_value = 24;
    let complex_result = "unknown";
    if test_value > 0 {
        if is_even(test_value) == 1 {
            if is_prime(test_value) == 1 {
                let complex_result = "even_prime";
            } else {
                if test_value > 20 {
                    if in_range(test_value, 20, 30) == 1 {
                        let complex_result = "large_even_composite_in_range";
                    } else {
                        let complex_result = "large_even_composite";
                    }
                } else {
                    let complex_result = "small_even_composite";
                }
            }
        } else {
            let complex_result = "odd";
        }
    }

    ut.assert_equals(complex_result, "large_even_composite_in_range", "24 should be classified correctly");
}

[test]
fn test_logical_combinations() {
    let a = 15;
    let b = 25;
    let c = 35;
    let all_positive = a > 0 && b > 0 && c > 0;
    ut.assert_equals(all_positive, true, "All should be positive");
    let any_even = is_even(a) == 1 || is_even(b) == 1 || is_even(c) == 1;
    ut.assert_equals(any_even, false, "None should be even");
    let in_sequence = b == a + 10 && c == b + 10;
    ut.assert_equals(in_sequence, true, "Should be in arithmetic sequence");
}

[test]
fn test_range_boundaries() {
    for test in range(0, 5) {
        let in_range_result = in_range(test, 1, 3);
        if test == 0 {
            ut.assert_equals(in_range_result, 0, "0 not in range 1-3");
        }

        if test == 1 || test == 2 || test == 3 {
            ut.assert_equals(in_range_result, 1, "value should be in range 1-3");
        }

        if test == 4 {
            ut.assert_equals(in_range_result, 0, "4 not in range 1-3");
        }
    }
}

[test]
fn test_recursive_fibonacci() {
    ut.assert_equals(fibonacci_recursive(7), 13, "fib_recursive(7) should be 13");
}

print ut.stats;
exit(ut.healthy);
